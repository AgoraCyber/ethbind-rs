{
  "bytes": {
    "declare_type": "Vec<u8>",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "Vec::<u8>::decode($inputs)"
  },
  "uint_m": {
    "declare_type": "int<false,$m>",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "int::<false,$m>::decode($inputs)"
  },
  "int_m": {
    "declare_type": "int<true,$m>",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "int::<true,$m>::decode($inputs)"
  },
  "fixed_m_n": {
    "declare_type": "fixed<true,$m,$n>",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "fixed::<true,$m,$n>::decode($inputs)"
  },
  "ufixed_m_n": {
    "declare_type": "fixed<true,$m,$n>",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "fixed::<true,$m,$n>::decode($inputs)"
  },
  "array_m": {
    "declare_type": "[$el;$m]",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "<[$el;$m]>::decode($inputs)"
  },
  "array": {
    "declare_type": "Vec<$el>",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "Vec<$el>::decode($inputs)"
  },
  "bytes_m": {
    "declare_type": "[u8;$m]",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "<[u8;$m]>::decode($inputs)"
  },
  "address": {
    "declare_type": "mock::Address",
    "rlp_encode": "$var.encode(&mut $outputs)",
    "rlp_decode": "mock::Address::decode($inputs)"
  },
  "rt_client": {
    "declare_type": "mock::Client",
    "rlp_encode": "",
    "rlp_decode": ""
  },
  "rt_error": {
    "declare_type": "anyhow::Error"
  },
  "rt_opts": {
    "declare_type": "mock::Ops"
  },
  "rt_receipt": {
    "declare_type": "mock::TransactionReceipt"
  }
}
